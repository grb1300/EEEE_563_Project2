/*
 * demo.c
 *
 *  Created on: Feb 14, 2021
 *      Author: larry kiser
 *  Updated on: Sept 9, 2025
 *      Author: Mitesh Parikh
 *
 *  Updated on: Sept 23, 2025 (added starter code for Input Capture)
 *      Author: Mitesh Parikh
 *
 *  Updated on: Sept 25, 2025 (fixed issue with PSC and updated code to show Period and Freq)
 *      Author: Mitesh Parikh
 */

// Standard includes
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <float.h>

// Custom Include files
#include "uart.h"
#include "stm32l476xx.h"
#include "demo.h"
#include "gpio.h"
#include "clock.h"
#include "LED.h"
// Added for Project 2
#include "timer.h"
#include <ctype.h>

// Global/Static variables
static uint32_t B1_Switch_Press_time_ms = 0;
static uint32_t one_second_counter = 0;
static uint8_t one_second_elapsed = 0;

#define PULSES_DEFAULT   1000u
#define LOWER_DEFAULT    1000u
#define PULSES_MIN       100u
#define PULSES_MAX       9999u
#define LOWER_MIN_US     100u
#define LOWER_MAX_US     9000u

enum Mode{
	AUTO_MODE,	//0
	MANUAL_MODE,
	PATTERN_MODE
};
enum Mode OP_MODE = AUTO_MODE;

enum ui_state_t{
    UI_INIT, //0
    UI_PROMPT_PULSES,
    UI_PROMPT_LOWER,
    UI_CONFIRM,
    UI_WAIT_START,
    UI_DONE
};

enum ui_state_t ui_state = UI_INIT;

static uint32_t num_pulses   = PULSES_DEFAULT;
static uint32_t lower_us     = LOWER_DEFAULT;
static uint32_t upper_us     = LOWER_DEFAULT + 100;

// crude delay for demos
static void delay_ms(uint32_t ms) {
    // use SysTick if you already set it; this is just a busy-wait fallback
    for (volatile uint32_t i = 0; i < (ms * 8000UL); ++i) __NOP(); // ~1ms @80MHz (rough)
}

// This function is to Initialize SysTick registers
void init_systick()
{
	// Use the SysTick global structure pointer to do the following in this
	// exact order with separate lines for each step:
	//
	// Disable SysTick by clearing the CTRL (CSR) register.
	SysTick->CTRL = 0UL;

	// Set the LOAD (RVR) to 15,999 to give us a 1 millisecond timer
	// System clock is 16MHz
	SysTick->LOAD |= (SysTick_LOAD_RELOAD_Msk & 15999UL);

	// Set the clock source bit in the CTRL (CSR) to the internal clock.
	SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;

	// Enable the interrupt bit
	SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;

	// Set the enable bit in the CTRL (CSR) to start the timer.
	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk ;
}

//******************************************************************************************
// This function is to handle SysTick Timer
//******************************************************************************************
void SysTick_Handler(void)
{
	//In this example, we will have LED blinking at One second interval so first Update One Second Counter
	//three_second_counter++;
	one_second_counter++;

	// Set a global One second elapsed flag when the handler has been called 1000 times
	// Once flag is set, reset the counter
	if (one_second_counter == 1000)
	{
		one_second_elapsed = true;
		one_second_counter = 0;
	}
}




//******************************************************************************************
// This function is to handle interrupts generated because of pressing B1 switch
//******************************************************************************************
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(GPIO_Pin == GPIO_PIN_13)
	{
		// Now that User pressed B1 switch, check how long switch is in pressed state
		// if Switch is released within 3 seconds then toggle between Auto and Manual modes
		// Add your code ---

		// If more than 3 second then Switch to Pattern Mode

		// Reset Switch time (in milliseconds)
		B1_Switch_Press_time_ms = 0;

		while(GPIO_PIN_RESET == HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13))
		{
			// Blocking code --

			// We can use SysTick Interrupt to keep track of time
			while(!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			{
				// do nothing -- Blocking code -- 1ms timer
			}
			B1_Switch_Press_time_ms++;

			// If we are in Auto mode and B1 Switch is Pressed for 3 Seconds or more then Switch to Pattern Mode
			// ---- Add your code
		}
	}
}

static char command_buffer[100];

//******************************************************************************************
// Run Demo -- main function with forever loop
//******************************************************************************************

void run_demo( void )
{
	// Default mode is Auto Mode
	printf("%s\r\n", "*** AUTO MODE ***");

	// Set buffer for Command Buffer
	uint32_t input_index = 0;
	memset(command_buffer, 0, 100);

	// Start forever loop
	while(1)
	{
		// Read USART to see if USER typed any commands
		char one_char = USART_Read_NB(USART2);
		(void) one_char;	/// avoid compiler warning

		if(OP_MODE == AUTO_MODE){
		    switch (ui_state){
		    	case UI_INIT:
					printf("%s\r\n", "\0");
					printf("%s\r\n", "*** Default Number of Pulses to read ***");
					printf("  Number of pulses : %lu\r\n", (unsigned long)num_pulses);
					printf("%s\r\n", "*** Default Lower Limit of the pulse ***");
					printf("  Lower limit (us) : %lu\r\n", (unsigned long)lower_us);
					printf("%s\r\n", "*** Default Upper Limit of the pulse ***");
					printf("  Upper limit (us) : %lu\r\n", (unsigned long)upper_us);
					printf("%s\r\n", "\0");
					ui_reset_line();
					ui_state = UI_PROMPT_PULSES;
					break;
		    	case UI_PROMPT_PULSES:
					if (one_char == 0x0D){
						if (input_index == 0){

						}
					}
						printf("%s\r\n", "\0");
						printf("%s\r\n", "*** ENTER Lower Limit of the pulse then press enter ***");
						printf("%s\r\n", "\0");

		        memset(command_buffer, 0, 100);
		        input_index = 0;
			} else if (one_char != '\0' && input_index < sizeof(command_buffer)-1) {
				command_buffer[input_index++] = one_char;
				command_buffer[input_index]   = '\0';
				printf("\r%s", command_buffer);
			}
		}
		// Switch between Modes

		// MP-Sept-25: Revised code for Input Capture Info, showing Period and Freq
		uint32_t ticks = TIM2_GetPeriodTicks(); // copy volatile safely
		if (ticks > 0)
		{
			float freq = 1e6f / ticks;
			printf("Period = %lu us, Freq = %.2f Hz\r\n", ticks, freq);
		}

		// MP-Sept-25: delay for demo only -- this is not required for Project as you will not be outputing anything until after
		// you have histogram is ready to display
		delay_ms(10);
	}
}
