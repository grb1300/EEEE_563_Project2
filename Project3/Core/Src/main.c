/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdbool.h>
#include <stdarg.h>
#include <float.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>  // Include this to use atoi
#include <string.h>
#include "uart.h"
#include "stm32l476xx.h"
#include "uart.h"
#include "timer.h"
#include <ctype.h>
#include "SysClock.h"

void GPIO_Init(void);
void TIM2_PWM_Init(void);
void UART_Init(void);
void UART_SendString(char* str);
void UART_SendChar(char c);
char UART_ReceiveChar();
void UART_Delay(uint32_t us);
void UART_Write(char *str);

// UART Ports:
// ===================================================
// PA.2 = USART2_TX (AF7)
// PA.3 = USART2_RX (AF7)

#define TX_PIN 2
#define RX_PIN 3

#define UPPER_BOUND
#define LOWER_BOUND
// Global/Static variables
static uint32_t B1_Switch_Press_time_ms = 0;
static uint32_t seventyFive_milisecond_counter = 0;
static uint8_t seventyFive_milisecond_elapsed = 0;
static uint8_t start_timer = 0;
static uint32_t N_milisecond_counter = 0;
static uint8_t N_milisecond_elapsed = 0;

enum ui_state_t{
    UI_INIT, //0
    UI_PROMPT_PULSES,
    UI_PROMPT_LOWER,
    UI_CONFIRM,
	UI_WAIT_SELECTION,
    UI_DONE
};
enum ui_state_t ui_state = UI_INIT;

// This function is to Initialize SysTick registers
void init_systick()
{
	// Use the SysTick global structure pointer to do the following in this
	// exact order with separate lines for each step:
	//
	// Disable SysTick by clearing the CTRL (CSR) register.
	SysTick->CTRL = 0UL;

	// Set the LOAD (RVR) to 15,999 to give us a 1 millisecond timer
	// System clock is 16MHz
	SysTick->LOAD |= (SysTick_LOAD_RELOAD_Msk & 15999UL);

	// Set the clock source bit in the CTRL (CSR) to the internal clock.
	SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;

	// Enable the interrupt bit
	SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;

	// Set the enable bit in the CTRL (CSR) to start the timer.
	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk ;
}

//******************************************************************************************
// This function is to handle SysTick Timer
//******************************************************************************************
void SysTick_Handler(void)
{
    if(start_timer == 1){
    	seventyFive_milisecond_counter++;

    	if (seventyFive_milisecond_counter >= 75)
    	{

    		seventyFive_milisecond_elapsed = 1;
    		seventyFive_milisecond_counter = 0;
    		start_timer = 0;
    	}
    }
}


static int parse_uint(const char *s, uint32_t *out){
    if (!s || !*s) return 0;
    uint32_t v = 0;
    for (const char *p = s; *p; ++p){
        if (!isdigit((unsigned char)*p)) return 0;
        v = (uint32_t)(v*10u + (uint32_t)(*p - '0'));
    }
    *out = v;
    return 1;
}


//******************************************************************************************
// This function is to handle interrupts generated because of pressing B1 switch
//******************************************************************************************
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{


	if(GPIO_Pin == GPIO_PIN_13)
	{
		// Now that User pressed B1 switch, check how long switch is in pressed state
		// if Switch is released within 3 seconds then toggle between Auto and Manual modes
		// Add your code ---

		// If more than 3 second then Switch to Pattern Mode

		// Reset Switch time (in milliseconds)
		B1_Switch_Press_time_ms = 0;

		while(GPIO_PIN_RESET == HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13))
		{
			// Blocking code --

			// We can use SysTick Interrupt to keep track of time
			while(!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			{
				// do nothing -- Blocking code -- 1ms timer
			}
			B1_Switch_Press_time_ms++;

			// If we are in Auto mode and B1 Switch is Pressed for 3 Seconds or more then Switch to Pattern Mode
			// ---- Add your code
		}
	}

}

int main(void)
{
    // Initialize GPIO, Timer, and UART
	System_Clock_Init(); // set System Clock = 80 MHz
	GPIO_Init();
    TIM2_PWM_Init();
    init_systick();
	USART2_Init(115200);
	USART2_WriteString("Complete Clock, GPIO and UART config!\r\n");
    UART_Init();

    char buffer[10];
    int pulse_width = 1000;  // Default 1ms pulse width

    while (1) {
        // Prompt user for new pulse width

    	UART_SendString("Enter new pulse width (in microseconds, 10-200): ");

        int i = 0;
        char c;

        // Read input from UART
        while ((c = UART_ReceiveChar()) != '\r') {
            buffer[i++] = c;
            UART_SendChar(c);  // Echo back the character
        }
        buffer[i] = '\0';  // Null-terminate the string
        UART_SendString("\n\r");

        // Convert input to integer
        pulse_width = atoi(buffer);

        // Validate pulse width (ensure it's between 10 and 200 microseconds)
        if (pulse_width < 10 || pulse_width > 200) {
            UART_SendString("Invalid input! Please enter a value between 400 and 2000.\n\r");
        } else {
            // Adjust PWM duty cycle based on the user input
            TIM2->CCR1 = pulse_width;
            UART_SendString("Pulse width updated!\n\r");
        }

    }

}

void GPIO_Init(void)
{
    // Enable GPIOA clock
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

    // Set PA5 to Alternate Function mode
    GPIOA->MODER &= ~(GPIO_MODER_MODE5);       // Clear PA5 mode bits
    GPIOA->MODER |= GPIO_MODER_MODE5_1;        // Set PA5 to AF mode

    // Select AF1 (TIM2_CH1) for PA5
    GPIOA->AFR[0] |= (1 << GPIO_AFRL_AFSEL5_Pos);  // Set AF1 (TIM2) for PA5

    // Set PA5 to Push-pull, No pull-up/down, High-speed
    GPIOA->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR5;
}

void TIM2_PWM_Init(void)
{
    // Enable TIM2 clock
    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;

    // Configure the timer for PWM
    TIM2->PSC = 7999;   // Prescaler value for 80 MHz / (7999 + 1) = 10 kHz
    TIM2->ARR = 199;    // Auto-reload value for 10 kHz / (199 + 1) = 50 Hz
    TIM2->CCR1 = 50;    // Initial duty cycle (adjust as necessary)

    // Set PWM mode 1 on TIM2 CH1 (active until match, inactive otherwise)
    TIM2->CCMR1 &= ~(TIM_CCMR1_OC1M); // Clear OC1M bits
    TIM2->CCMR1 |= (0x6 << TIM_CCMR1_OC1M_Pos); // Set PWM mode 1 (110)
    TIM2->CCMR1 |= TIM_CCMR1_OC1PE; // Enable preload register on CCR1

    // Enable capture/compare for channel 1
    TIM2->CCER |= TIM_CCER_CC1E; // Enable TIM2 CH1 output

    // Enable the counter
    TIM2->CR1 |= TIM_CR1_CEN; // Enable timer
}

void UART_Init( void )
{

	// Enable the clock of USART 1 & 2
	RCC->APB1ENR1 |= RCC_APB1ENR1_USART2EN;  // Enable USART 2 clock

	// Select the USART1 clock source
	// 00: PCLK selected as USART2 clock
	// 01: System clock (SYSCLK) selected as USART2 clock
	// 10: HSI16 clock selected as USART2 clock
	// 11: LSE clock selected as USART2 clock
	RCC->CCIPR &= ~RCC_CCIPR_USART2SEL;
	RCC->CCIPR |=  RCC_CCIPR_USART2SEL_0;


	// Enable USART2 clock (assuming PA2 for TX and PA3 for RX)
	RCC->APB1ENR1 |= RCC_APB1ENR1_USART2EN;
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;


	// ********************** USART 2 ***************************
	// PA2 = USART2_TX (AF7)
	// PA3 = USART2_RX (AF7)
	// Alternate function, High Speed, Push pull, Pull up
	// **********************************************************
	// Input(00), Output(01), AlterFunc(10), Analog(11)
	GPIOA->MODER   &= ~(3<<(2*TX_PIN) | 3<<(2*RX_PIN));	// Clear bits
	GPIOA->MODER   |=   2<<(2*TX_PIN) | 2<<(2*RX_PIN);
	GPIOA->AFR[0]  &= ~(0xF<<(4*TX_PIN) | 0xF<<(4*RX_PIN));
	GPIOA->AFR[0]  |=   7<<(4*TX_PIN) | 7<<(4*RX_PIN);
	// GPIO Speed: Low speed (00), Medium speed (01), Fast speed (10), High speed (11)
	GPIOA->OSPEEDR |=   3<<(2*TX_PIN) | 3<<(2*RX_PIN);
	// GPIO Push-Pull: No pull-up, pull-down (00), Pull-up (01), Pull-down (10), Reserved (11)
	GPIOA->PUPDR   &= ~(3<<(2*TX_PIN) | 3<<(2*RX_PIN));
	// GPIO Output Type: Output push-pull (0, reset), Output open drain (1)
	GPIOA->OTYPER  &=  ~(1<<TX_PIN | 1<<RX_PIN);

	// Default setting:
	//     No hardware flow control, 8 data bits, no parity, 1 start bit and 1 stop bit
	USART2->CR1 &= ~USART_CR1_UE;  // Disable USART

	// Configure word length to 8 bit
	USART2->CR1 &= ~USART_CR1_M;   // M: 00 = 8 data bits, 01 = 9 data bits, 10 = 7 data bits

	// Configure oversampling mode: Oversampling by 16
	USART2->CR1 &= ~USART_CR1_OVER8;  // 0 = oversampling by 16, 1 = oversampling by 8

	// Configure stop bits to 1 stop bit
	//   00: 1 Stop bit;      01: 0.5 Stop bit
	//   10: 2 Stop bits;     11: 1.5 Stop bit
	USART2->CR2 &= ~USART_CR2_STOP;

	// CSet Baudrate to 9600 using APB frequency (80,000,000 Hz)
	// If oversampling by 16, Tx/Rx baud = f_CK / USARTDIV,
	// If oversampling by 8,  Tx/Rx baud = 2*f_CK / USARTDIV
	// When OVER8 = 0, BRR = USARTDIV
	// USARTDIV = 80MHz/9600 = 8333 = 0x208D
	USART2->BRR  = 0x208D; // Limited to 16 bits

	USART2->CR1  |= (USART_CR1_RE | USART_CR1_TE);  	// Transmitter and Receiver enable


	USART2->ICR |= USART_ICR_TCCF;


	USART2->CR1  |= USART_CR1_UE; // USART enable

	while ( (USART2->ISR & USART_ISR_TEACK) == 0); // Verify that the USART is ready for reception
	while ( (USART2->ISR & USART_ISR_REACK) == 0); // Verify that the USART is ready for transmission
}

char UART_ReceiveChar()
{
    while (!(USART2->ISR & USART_ISR_RXNE)); // Wait until data is received
    return ((char)(USART2->RDR & 0xFF));
}


void UART_Write(char *str)
{
	int i;
	uint32_t nBytes = strlen(str);

	// TXE is cleared by a write to the USART_DR register.
	// TXE is set by hardware when the content of the TDR
	// register has been transferred into the shift register.
	for (i = 0; i < nBytes; i++)
	{
		while (!(USART2->ISR & USART_ISR_TXE));   	// wait until TXE (TX empty) bit is set
		// Writing USART_DR automatically clears the TXE flag
		USART2->TDR = str[i] & 0xFF;
		UART_Delay(300);
	}
	while (!(USART2->ISR & USART_ISR_TC));   		  // wait until TC bit is set
	USART2->ISR &= ~USART_ISR_TC;
}


void UART_SendChar(char c)
{
    // Wait until the transmit data register is empty
    while (!(USART2->ISR & USART_ISR_TXE));
    USART2->TDR = c; // Transmit the character
	UART_Delay(300);

    // Writing USART_DR automatically clears the TXE flag
	while (!(USART2->ISR & USART_ISR_TC));   		  // wait until TC bit is set
	USART2->ISR &= ~USART_ISR_TC;
}

void UART_SendString(char* str)
{
    while (*str)
    {
        UART_SendChar(*str++);
    }
}

void UART_Delay(uint32_t us)
{
	uint32_t time = 100*us/7;
	while(--time);
}


